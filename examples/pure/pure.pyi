# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import collections.abc
import datetime
import os
import pathlib
import typing
import typing_extensions
from enum import Enum

MY_CONSTANT: builtins.int
class A:
    NUM1: builtins.int = 2
    r"""
    class attribute NUM1
    """
    NUM2: builtins.int
    r"""
    class attribute NUM2
    """
    @property
    def x(self) -> builtins.int:
        r"""
        ```python
        default = 2
        ```
        """
    @x.setter
    def x(self, value: builtins.int) -> None:
        r"""
        ```python
        default = 2
        ```
        """
    def __new__(cls, x:builtins.int) -> A:
        r"""
        This is a constructor of :class:`A`.
        """
    @classmethod
    def classmethod_test1(cls) -> None: ...
    @classmethod
    def classmethod_test2(cls) -> None: ...
    def show_x(self) -> None: ...
    def ref_test(self, x:dict) -> dict: ...
    async def async_get_x(self) -> builtins.int: ...
    @typing_extensions.deprecated("since=1.0.0, This method is deprecated")
    def deprecated_method(self) -> None: ...

class B(A):
    ...

class Incrementer:
    @typing.overload
    def increment_1(self, x:builtins.int) -> builtins.int:
        r"""
        And this is for the second comment
        """
    @typing.overload
    def increment_1(self, x:builtins.float) -> builtins.float:
        r"""
        This is the original doc comment
        """
    def new(self) -> Incrementer: ...

class Incrementer2:
    @typing.overload
    def increment_2(self, x:builtins.int) -> builtins.int:
        r"""
        increment_2 for integers, submitted by hands
        """
    @typing.overload
    def increment_2(self, x:builtins.float) -> builtins.float:
        r"""
        increment_2 for floats, submitted by hands
        """
    def __new__(cls) -> Incrementer2:
        r"""
        Constructor for Incrementer2
        """

class MyDate(datetime.date):
    ...

class NumberComplex:
    class FLOAT(NumberComplex):
        r"""
        Float variant
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.float: ...
        def __new__(cls, _0:builtins.float) -> NumberComplex.FLOAT: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class INTEGER(NumberComplex):
        r"""
        Integer variant
        """
        __match_args__ = ("int",)
        @property
        def int(self) -> builtins.int:
            r"""
            The integer value
            """
        def __new__(cls, int:builtins.int=2) -> NumberComplex.INTEGER: ...
    
    ...

class OverrideType:
    @property
    def num(self) -> int: ...
    @num.setter
    def num(self, value: str) -> None: ...
    def error(self) -> typing_extensions.Never: ...

class Shape1:
    r"""
    Example from PyO3 documentation for complex enum
    https://pyo3.rs/v0.25.1/class.html#complex-enums
    """
    class Circle(Shape1):
        __match_args__ = ("radius",)
        @property
        def radius(self) -> builtins.float: ...
        def __new__(cls, radius:builtins.float) -> Shape1.Circle: ...
    
    class Rectangle(Shape1):
        __match_args__ = ("width", "height",)
        @property
        def width(self) -> builtins.float: ...
        @property
        def height(self) -> builtins.float: ...
        def __new__(cls, width:builtins.float, height:builtins.float) -> Shape1.Rectangle: ...
    
    class RegularPolygon(Shape1):
        __match_args__ = ("_0", "_1",)
        @property
        def _0(self) -> builtins.int: ...
        @property
        def _1(self) -> builtins.float: ...
        def __new__(cls, _0:builtins.int, _1:builtins.float) -> Shape1.RegularPolygon: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Nothing(Shape1):
        __match_args__ = ((),)
        def __new__(cls) -> Shape1.Nothing: ...
    
    ...

class Shape2:
    r"""
    Example from PyO3 documentation for complex enum
    https://pyo3.rs/v0.25.1/class.html#complex-enums
    """
    class Circle(Shape2):
        __match_args__ = ("radius",)
        @property
        def radius(self) -> builtins.float: ...
        def __new__(cls, radius:builtins.float=1.0) -> Shape2.Circle: ...
    
    class Rectangle(Shape2):
        __match_args__ = ("width", "height",)
        @property
        def width(self) -> builtins.float: ...
        @property
        def height(self) -> builtins.float: ...
        def __new__(cls, *, width:builtins.float, height:builtins.float) -> Shape2.Rectangle: ...
    
    class RegularPolygon(Shape2):
        __match_args__ = ("side_count", "radius",)
        @property
        def side_count(self) -> builtins.int: ...
        @property
        def radius(self) -> builtins.float: ...
        def __new__(cls, side_count:builtins.int, radius:builtins.float=1.0) -> Shape2.RegularPolygon: ...
    
    class Nothing(Shape2):
        __match_args__ = ((),)
        def __new__(cls) -> Shape2.Nothing: ...
    
    ...

class Number(Enum):
    FLOAT = ...
    INTEGER = ...

    @property
    def is_float(self) -> builtins.bool:
        r"""
        Whether the number is a float.
        """
    @property
    def is_integer(self) -> builtins.bool:
        r"""
        Whether the number is an integer.
        """

class NumberRenameAll(Enum):
    FLOAT = ...
    r"""
    Float variant
    """
    INTEGER = ...

def ahash_dict() -> builtins.dict[builtins.str, builtins.int]: ...

async def async_num() -> builtins.int: ...

def create_a(x:builtins.int=2) -> A: ...

def create_dict(n:builtins.int) -> builtins.dict[builtins.int, builtins.list[builtins.int]]: ...

def default_value(num:Number=Number.FLOAT) -> Number: ...

@typing_extensions.deprecated("since=1.0.0, This function is deprecated")
def deprecated_function() -> None: ...

def echo_path(path:builtins.str | os.PathLike | pathlib.Path) -> pathlib.Path: ...

def fn_override_type(cb:collections.abc.Callable[[str]]) -> collections.abc.Callable[[str]]: ...

@typing.overload
def overload_example_1(x:builtins.int) -> builtins.int: ...

@typing.overload
def overload_example_1(x:builtins.float) -> builtins.float:
    r"""
    First example: One generated with ordinary `#[gen_stub_pyfunction]`,
    and then manually with `submit!` macro.
    """

@typing.overload
def overload_example_2(x:builtins.int) -> builtins.int:
    r"""
    Increments integer by 1
    """

@typing.overload
def overload_example_2(x:builtins.float) -> builtins.float:
    r"""
    Increments float by 1
    """

def print_c(c:typing.Optional[builtins.int]=None) -> None: ...

def read_dict(dict:typing.Mapping[builtins.int, typing.Mapping[builtins.int, builtins.int]]) -> None: ...

def str_len(x:builtins.str) -> builtins.int:
    r"""
    Returns the length of the string.
    """

def sum(v:typing.Sequence[builtins.int]) -> builtins.int:
    r"""
    Returns the sum of two numbers as a string.
    """

class MyError(RuntimeError): ...

