# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401
r"""
Document for pure ...
"""

import builtins
import collections.abc
import datetime
import decimal
import enum
import os
import pathlib
import typing
import typing_extensions

MY_CONSTANT1: builtins.int
MY_CONSTANT2: builtins.int = 123
class A:
    NUM: builtins.int = 2
    r"""
    class attribute NUM1
    """
    NUM3: builtins.int = 3
    r"""
    deprecated class attribute NUM3 (will show warning)
    """
    NUM2: builtins.int
    r"""
    class attribute NUM2
    """
    @property
    def x(self) -> builtins.int:
        r"""
        ```python
        default = 2
        ```
        """
    @x.setter
    def x(self, value: builtins.int) -> None:
        r"""
        ```python
        default = 2
        ```
        """
    @property
    def y(self) -> builtins.int: ...
    @y.setter
    @typing_extensions.deprecated("[Since 1.0.0] This setter is deprecated")
    def y(self, value: builtins.int) -> None: ...
    @typing_extensions.deprecated("[Since 1.0.0] This method is deprecated")
    @property
    def deprecated_getter(self) -> builtins.int: ...
    def __new__(cls, x:builtins.int) -> A:
        r"""
        This is a constructor of :class:`A`.
        """
    @classmethod
    def classmethod_test1(cls) -> None: ...
    @typing_extensions.deprecated("[Since 1.0.0] This classmethod is deprecated")
    @classmethod
    def deprecated_classmethod(cls) -> None: ...
    @classmethod
    def classmethod_test2(cls) -> None: ...
    def show_x(self) -> None: ...
    def ref_test(self, x:dict) -> dict: ...
    async def async_get_x(self) -> builtins.int: ...
    @typing_extensions.deprecated("[Since 1.0.0] This method is deprecated")
    def deprecated_method(self) -> None: ...
    @typing_extensions.deprecated("[Since 1.0.0] This staticmethod is deprecated")
    @staticmethod
    def deprecated_staticmethod() -> builtins.int: ...

@typing.final
class B(A):
    ...

@typing.final
class ComparableStruct:
    r"""
    Test struct for eq and ord comparison methods
    """
    @property
    def value(self) -> builtins.int: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __lt__(self, other:builtins.object) -> builtins.bool: ...
    def __le__(self, other:builtins.object) -> builtins.bool: ...
    def __gt__(self, other:builtins.object) -> builtins.bool: ...
    def __ge__(self, other:builtins.object) -> builtins.bool: ...
    def __new__(cls, value:builtins.int) -> ComparableStruct: ...

@typing.final
class DecimalHolder:
    @property
    def value(self) -> decimal.Decimal: ...
    def __new__(cls, value:decimal.Decimal) -> DecimalHolder: ...

@typing.final
class HashableStruct:
    r"""
    Test struct for hash and str methods
    """
    @property
    def name(self) -> builtins.str: ...
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __str__(self) -> builtins.str: ...
    def __new__(cls, name:builtins.str) -> HashableStruct: ...

@typing.final
class Incrementer:
    @typing.overload
    def increment_1(self, x:int) -> int:
        r"""
        And this is for the second comment
        """
    @typing.overload
    def increment_1(self, x:builtins.float) -> builtins.float:
        r"""
        This is the original doc comment
        """
    def __new__(cls) -> Incrementer: ...

@typing.final
class Incrementer2:
    @typing.overload
    def increment_2(self, x:int) -> int:
        r"""
        increment_2 for integers, submitted by hands
        """
    @typing.overload
    def increment_2(self, x:float) -> float:
        r"""
        increment_2 for floats, submitted by hands
        """
    def __new__(cls) -> Incrementer2:
        r"""
        Constructor for Incrementer2
        """

@typing.final
class MyDate(datetime.date):
    ...

class MyError(builtins.RuntimeError):
    ...

@typing.final
class NotIntError(builtins.TypeError):
    r"""
    A manual custom exception case
    
    Based on the code reported in https://github.com/Jij-Inc/pyo3-stub-gen/issues/263
    """
    def __new__(cls, item:typing.Any) -> NotIntError: ...
    def __str__(self) -> builtins.str: ...
    def trivial_number(self) -> builtins.int:
        r"""
        A trivial number
        """
    def item_is_str(self) -> builtins.bool:
        r"""
        Checks if the item is a string
        """

class NumberComplex:
    @typing.final
    class FLOAT(NumberComplex):
        r"""
        Float variant
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.float: ...
        def __new__(cls, _0:builtins.float) -> NumberComplex.FLOAT: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    @typing.final
    class INTEGER(NumberComplex):
        r"""
        Integer variant
        """
        __match_args__ = ("int",)
        @property
        def int(self) -> builtins.int:
            r"""
            The integer value
            """
        def __new__(cls, int:builtins.int=2) -> NumberComplex.INTEGER: ...
    
    ...

@typing.final
class OverrideType:
    @property
    def num(self) -> int: ...
    @num.setter
    def num(self, value: str) -> None: ...
    def error(self) -> typing_extensions.Never: ...

class Shape1:
    r"""
    Example from PyO3 documentation for complex enum
    https://pyo3.rs/v0.25.1/class.html#complex-enums
    """
    @typing.final
    class Circle(Shape1):
        __match_args__ = ("radius",)
        @property
        def radius(self) -> builtins.float: ...
        def __new__(cls, radius:builtins.float) -> Shape1.Circle: ...
    
    @typing.final
    class Rectangle(Shape1):
        __match_args__ = ("width", "height",)
        @property
        def width(self) -> builtins.float: ...
        @property
        def height(self) -> builtins.float: ...
        def __new__(cls, width:builtins.float, height:builtins.float) -> Shape1.Rectangle: ...
    
    @typing.final
    class RegularPolygon(Shape1):
        __match_args__ = ("_0", "_1",)
        @property
        def _0(self) -> builtins.int: ...
        @property
        def _1(self) -> builtins.float: ...
        def __new__(cls, _0:builtins.int, _1:builtins.float) -> Shape1.RegularPolygon: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    @typing.final
    class Nothing(Shape1):
        __match_args__ = ()
        def __new__(cls) -> Shape1.Nothing: ...
    
    ...

class Shape2:
    r"""
    Example from PyO3 documentation for complex enum
    https://pyo3.rs/v0.25.1/class.html#complex-enums
    """
    @typing.final
    class Circle(Shape2):
        __match_args__ = ("radius",)
        @property
        def radius(self) -> builtins.float: ...
        def __new__(cls, radius:builtins.float=1.0) -> Shape2.Circle: ...
    
    @typing.final
    class Rectangle(Shape2):
        __match_args__ = ("width", "height",)
        @property
        def width(self) -> builtins.float: ...
        @property
        def height(self) -> builtins.float: ...
        def __new__(cls, *, width:builtins.float, height:builtins.float) -> Shape2.Rectangle: ...
    
    @typing.final
    class RegularPolygon(Shape2):
        __match_args__ = ("side_count", "radius",)
        @property
        def side_count(self) -> builtins.int: ...
        @property
        def radius(self) -> builtins.float: ...
        def __new__(cls, side_count:builtins.int, radius:builtins.float=1.0) -> Shape2.RegularPolygon: ...
    
    @typing.final
    class Nothing(Shape2):
        __match_args__ = ()
        def __new__(cls) -> Shape2.Nothing: ...
    
    ...

@typing.final
class TypeIgnoreTest:
    r"""
    Test class for method type: ignore functionality
    """
    def __new__(cls) -> TypeIgnoreTest: ...
    def test_method_ignore(self, value:builtins.int) -> builtins.int:  # type: ignore[union-attr,return-value]
        r"""
        Test method with type: ignore for specific rules
        """
    def test_method_all_ignore(self) -> builtins.int:  # type: ignore
        r"""
        Test method with type: ignore (without equals for catch-all)
        """

@typing.final
class Number(enum.Enum):
    FLOAT = ...
    INTEGER = ...

    @property
    def is_float(self) -> builtins.bool:
        r"""
        Whether the number is a float.
        """
    @property
    def is_integer(self) -> builtins.bool:
        r"""
        Whether the number is an integer.
        """

@typing.final
class NumberRenameAll(enum.Enum):
    FLOAT = ...
    r"""
    Float variant
    """
    INTEGER = ...

def add_decimals(a:decimal.Decimal, b:decimal.Decimal) -> decimal.Decimal:
    r"""
    Add two decimal numbers with high precision
    """

def ahash_dict() -> builtins.dict[builtins.str, builtins.int]: ...

async def async_num() -> builtins.int: ...

def create_a(x:builtins.int=2) -> A: ...

def create_dict(n:builtins.int) -> builtins.dict[builtins.int, builtins.list[builtins.int]]: ...

def default_value(num:Number=Number.FLOAT) -> Number: ...

@typing_extensions.deprecated("[Since 1.0.0] This function is deprecated")
def deprecated_function() -> None: ...

def echo_path(path:builtins.str | os.PathLike | pathlib.Path) -> pathlib.Path: ...

def fn_override_type(cb:collections.abc.Callable[[str], typing.Any]) -> collections.abc.Callable[[str], typing.Any]: ...

def fn_with_python_param(callback:collections.abc.Callable[[str], typing.Any]) -> collections.abc.Callable[[str], typing.Any]:
    r"""
    Example using python parameter in gen_stub_pyfunction attribute.
        This demonstrates specifying types directly in Python stub syntax.
    """

def fn_with_python_stub(callback:collections.abc.Callable[[str], typing.Any]) -> collections.abc.Callable[[str], typing.Any]:
    r"""
    Example function using gen_function_from_python! macro.
        This demonstrates how to define type information using Python stub syntax.
    """

def func_with_kwargs(**kwargs) -> builtins.bool:
    r"""
    Takes a variable number of keyword arguments and does nothing
    """

def func_with_star_arg(*args) -> builtins.str:
    r"""
    Takes a variable number of arguments and returns their string representation.
    """

@typing.overload
def overload_example_1(x:int) -> int: ...

@typing.overload
def overload_example_1(x:builtins.float) -> builtins.float:
    r"""
    First example: One generated with ordinary `#[gen_stub_pyfunction]`,
    and then manually with `submit!` macro.
    """

@typing.overload
def overload_example_2(ob:int) -> int:
    r"""
    Increments integer by 1
    """

@typing.overload
def overload_example_2(ob:float) -> float:
    r"""
    Increments float by 1
    """

def print_c(c:typing.Optional[builtins.int]=None) -> None: ...

def read_dict(dict:typing.Mapping[builtins.int, typing.Mapping[builtins.int, builtins.int]]) -> None: ...

def str_len(x:builtins.str) -> builtins.int:
    r"""
    Returns the length of the string.
    """

def sum(v:typing.Sequence[builtins.int]) -> builtins.int:
    r"""
    Returns the sum of two numbers as a string.
    """

def test_type_ignore_all() -> builtins.int:  # type: ignore
    r"""
    Test function with type: ignore (without equals for catch-all)
    """

def test_type_ignore_custom() -> builtins.int:  # type: ignore[custom-rule,attr-defined]
    r"""
    Test function with custom (unknown) rule
    """

def test_type_ignore_no_comment_all() -> builtins.int: ...  # type: ignore

def test_type_ignore_no_comment_specific() -> builtins.int: ...  # type: ignore[arg-type,reportIncompatibleMethodOverride]

def test_type_ignore_pyright() -> builtins.int:  # type: ignore[reportGeneralTypeIssues,reportReturnType]
    r"""
    Test function with Pyright diagnostic rules
    """

def test_type_ignore_specific() -> builtins.int:  # type: ignore[arg-type,return-value]
    r"""
    Test function with type: ignore for specific rules
    """

