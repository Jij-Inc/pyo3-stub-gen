use crate::generate::*;
use itertools::Itertools;
use std::{
    any::TypeId,
    collections::{BTreeMap, BTreeSet},
    fmt,
};

/// Type info for a Python (sub-)module. This corresponds to a single `*.pyi` file.
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Module {
    pub class: BTreeMap<TypeId, ClassDef>,
    pub enum_: BTreeMap<TypeId, EnumDef>,
    pub function: BTreeMap<&'static str, FunctionDef>,
    pub error: BTreeMap<&'static str, ErrorDef>,
    pub variables: BTreeMap<&'static str, VariableDef>,
    pub name: String,
    pub default_module_name: String,
    /// Direct submodules of this module.
    pub submodules: BTreeSet<String>,
}

impl Import for Module {
    fn import(&self) -> HashSet<ImportRef> {
        let mut imports = HashSet::new();
        for class in self.class.values() {
            imports.extend(class.import());
        }
        for function in self.function.values() {
            imports.extend(function.import());
        }
        imports
    }
}

impl fmt::Display for Module {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        writeln!(f, "# This file is automatically generated by pyo3_stub_gen")?;
        writeln!(f, "# ruff: noqa: E501, F401")?;
        writeln!(f)?;
        let package_name = self.default_module_name.split('.').next().unwrap();
        let mut type_ref_grouped: BTreeMap<String, Vec<String>> = BTreeMap::new();
        for common_ref in self.import().into_iter().sorted() {
            match common_ref {
                ImportRef::Module(module_ref) => {
                    let name = module_ref.get().unwrap_or(&self.default_module_name);
                    if name != self.name {
                        println!("Name: {}", name,);
                        writeln!(f, "import {}", name)?;
                    }
                }
                ImportRef::Type(type_ref) => {
                    let module_name = type_ref.module.get().unwrap_or(&self.default_module_name);
                    if module_name != self.name {
                        if module_name.starts_with(package_name) {
                            type_ref_grouped
                                .entry(module_name.to_string())
                                .or_default()
                                .push(type_ref.name);
                        } else {
                            writeln!(f, "import {}", module_name)?;
                        }
                    }
                }
            }
        }
        for (module_name, type_names) in type_ref_grouped {
            let mut sorted_type_names = type_names.clone();
            sorted_type_names.sort();
            writeln!(f, "from {} import {}", module_name, sorted_type_names.join(", "))?;
        }
        for submod in &self.submodules {
            writeln!(f, "from . import {}", submod)?;
        }
        if !self.enum_.is_empty() {
            writeln!(f, "from enum import Enum")?;
        }
        writeln!(f)?;

        for var in self.variables.values() {
            writeln!(f, "{}", var)?;
        }
        for class in self.class.values().sorted_by_key(|class| class.name) {
            write!(f, "{}", class)?;
        }
        for enum_ in self.enum_.values().sorted_by_key(|class| class.name) {
            write!(f, "{}", enum_)?;
        }
        for function in self.function.values() {
            write!(f, "{}", function)?;
        }
        for error in self.error.values() {
            writeln!(f, "{}", error)?;
        }
        Ok(())
    }
}
